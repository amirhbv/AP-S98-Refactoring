\documentclass{utap}

\usepackage{keyval}
\usepackage{calc}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{amsmath}
% \usepackage{wrapfig}
\usepackage{xepersian}

\graphicspath{ {./images/} }

\title{تمرین  امتیازی}
\author{
    \href{mailto:bardia.eghbali@gmail.com?subject=[AP\%20S98\%20Refactoring]\%20}{بردیا اقبالی},
    \href{mailto:ahhabibvand@gmail.com?subject=[AP\%20S98\%20Refactoring]\%20}{امیرحسین حبیب‌وند}
}
\course{برنامه‌سازی پیشرفته}
\deadline{جمعه ۱۶ فروردین ۱۳۹۸، ساعت ۲۳:۵۵}
\lecturer{رامتین خسروی}

\begin{document}

\lstset{
    numbers=left,
    frame=leftline,
}

\maketitle

\section{بازسازی}
تعاریف زیادی از
"ﮐﺪ ﺗﻤﯿﺰ"\LTRfootnote{Clean Code}
وجود دارد؛ اما احتمالا یکی از بهترین تعریف‌ها متعلق به
"ﺑﯿﺎرﻧﻪ اﺳﺘﺮاﺳﺘﺮوپ" \LTRfootnote{Bjarne Stroustrup}
خالق و توسعه‌دهنده‌ی زبان \lr{\texttt{C++}} است. وی ر تعریف خود از یک کد تمیز، دو مورد زیر را به عنوان معیار‌های اساسی یک کد تمیز بر می‌شمارد:

    \begin{itemize}
        \item
منطق و الگوریتم کد باید آن‌قدر واضح و قابل‌فهم باشد که اشکالات و نقص‌های ﺟﺰﺋﯽ نتوانند از چشم برنامه‌نویس و آزمونگر کد دور بمانند؛ ضمن این که وضوح کد باید به حدی بالا باشد که برنامه‌نویس را از نوشتن کامنت\LTRfootnote{Comment} بی‌نیاز کند.

        \item
کارایی\LTRfootnote{Performance}
برنامه نوشته‌شده باید در بهینه‌ترین\LTRfootnote{Optimal}
شکل ممکن باشد تا بعدها برنامه‌نویس دیگری به بهانه‌ی بهینه‌سازی\LTRfootnote{Optimization}
برنامه‌ی سابق با ایجاد تغییرات نادرست سبب نامنظم‌شدن و کثیف‌شدن کد نشود.
    \end{itemize}

در عمل، در اکثر مواقع شما بعد از یک طراحی نسبتاً خوب و پیاده‌سازی آن، برای مدتی طولانی از آن کد برا هدف خود استفاده می‌کنید و در طول این مدت تعییرات و قابلیت‌های زیادی را به آن می‌افزایید.

پس از مدتی نه‌چندان طولانی، این تغییرات باعث می‌شوند که شما دیگر عملکرد کد را به‌وضوح متوجه نشوید و به تبع آن، توانایی تغییر و ارتقای کد را نیز از دست می‌دهید. همین زنجیره‌ی اتفاقات به ظاهر ساده در تاریخچه‌ی نسبتاً کوتاه توسعه‌ی نرم‌افزاری باعث نابود‌شدن شرکت‌های بسیاری در این عرصه شده است.

حال با توجه به خطرات و مشکلاتی که یک کد کثیف به همراه دارد، باید راه‌حلی برای رفع کثیف‌بودن کد و جلو‌‌گیری از ایجاد آن اراﺋﻪ دهیم. شما در این تمرین کامپیوتری با روند بازسازی\LTRfootnote{Refactoring} کد آشنا می‌شوید.

بازسازی عملیاتی است که در طی آن ساختار یک نرم افزار به صورتی تغییر و بهبود می‌یابد که بدون از دست‌رفتن کارآیی‌ها و تغییر رابط کاربری\LTRfootnote{Interface} برنامه، ساختار درونی کد به طرز قابل توجهی تمیزتر می‌شود.

بنیادی‌ترین مفهوم یاری‌کننده‌ی یک برنامه‌نویس در طی عملیات بازسازی شناخت عناصری است که باعث کثیف شدن کدها می‌شوند و به اصطلاح به آن‌ها Code Smells گفته می‌شود.

وظیفه‌ی شما در این تمرین بازسازی کد خودتان در تمرین اول درس است؛ بنابراین \textbf{خوانایی و تمیزبودن کد} در این تمرین بیشترین اهمیت را دارد. در ادامه توضیحاتی درباره‌ی بازسازی کد اراﺋﻪ می‌شود. پیشنهاد می‌کنیم که ابتدا تا پایان صورت تمرین را مطالعه کنید و سپس شروع به بازسازی کد خود کنید.
\newpage
\section{کد تمیز}
عواملی در کد وجود دارند که ممکن است باعث کثیف‌شدن آن شوند؛ در ادامه برخی از این عوامل توضیح داده شده‌اند. توجه کنید که در انتهای این تمرین نمره شما فقط بر اساس عوامل زیر سنجیده می‌شود و به ازای هر یک از موارد زیر که در کد شما وجو داشته باشد نمره‌ی شما کاسته خواهد شد. ساختار کلی کد و طراحی شما نباید تغییر کند و فقط ساختار درونی آن می‌تواند تغییر کند.\\
این عوامل خلاصه‌ای از کتاب Clean Code هستند و عبارت انتهای هر عامل فصل و شماره‌ای آن عامل را در کتاب نشان می‌دهد.

\subsection{نام‌گذاری (فصل ۲)}
  \begin{itemize}
        \item
    \end{itemize}

\subsection{توابع (فصل ۳)}
  \begin{itemize}
        \item
    \end{itemize}

\subsection{فرمتینگ (فصل ۵)}
  \begin{itemize}
        \item 
    \end{itemize}


\subsection{\lr{Smells and Heuristics} (فصل ۱۷)}

	\subsubsection{کامنت‌ها}
	  \begin{itemize}
	        \item در این تمرین کامنت‌گذاری به هیچ نحوی قابل قبول نیست.
	    \end{itemize}


	\subsubsection{توابع}
	  \begin{itemize}
	        \item آرگومان‌هایی که به عنوان خروجی تابع استفاده می‌شوند. یک تابع فقط باید بتواند از طریق مقدار بازگشتی خود بر محیط بیرون تأثیر بگذارد و نتواند از طریق تغییر آرگومان‌ها بر محیط تأثیری داشته باشد.
		\item آرگومان از نوع بولین\LTRfootnote{Boolean} برای تعیین نحوه عملکرد کد؛
مثلا پاس دادن یک متغیر به نام \lr{flag} به تابع، فقط برای اجرای یک بخش کد در حالتی خاص. چنین تابعی در واقع دو تابع مختلف است که باید به صورت جدا از هم پیاده‌سازی شوند و در زمان مناسب صدا\LTRfootnote{call} شوند.
	    \end{itemize}

\end{document}
