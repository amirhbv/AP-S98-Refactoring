\documentclass{utap}

\usepackage{keyval}
\usepackage{calc}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{xepersian}

\graphicspath{ {./images/} }

\title{تمرین  امتیازی}
\author{
    \href{mailto:bardia.eghbali@gmail.com?subject=[AP\%20S98\%20Refactoring]\%20}{بردیا اقبالی},
    \href{mailto:ahhabibvand@gmail.com?subject=[AP\%20S98\%20Refactoring]\%20}{امیرحسین حبیب‌وند}
}
\course{برنامه‌سازی پیشرفته}
\deadline{جمعه ۱۶ فروردین ۱۳۹۸، ساعت ۲۳:۵۵}
\lecturer{رامتین خسروی}

\begin{document}

\lstset{
    numbers=left,
    frame=leftline,
}

\maketitle

\section{بازسازی}
تعاریف زیادی از
"ﮐﺪ ﺗﻤﯿﺰ"\LTRfootnote{Clean Code}
وجود دارد؛ اما احتمالا یکی از بهترین تعریف‌ها متعلق به
"ﺑﯿﺎرﻧﻪ اﺳﺘﺮاﺳﺘﺮوپ" \LTRfootnote{Bjarne Stroustrup}
خالق و توسعه‌دهنده‌ی زبان \lr{\texttt{C++}} است. وی در تعریف خود از یک کد تمیز، دو مورد زیر را به عنوان معیار‌های اساسی یک کد تمیز بر می‌شمارد:

    \begin{itemize}
        \item
منطق و الگوریتم کد باید آن‌قدر واضح و قابل‌فهم باشد که اشکالات و نقص‌های ﺟﺰﺋﯽ نتوانند از چشم برنامه‌نویس و آزمونگر کد دور بمانند؛ ضمن این که وضوح کد باید به حدی بالا باشد که برنامه‌نویس را از نوشتن کامنت\LTRfootnote{Comment} بی‌نیاز کند.

        \item
کارایی\LTRfootnote{Performance}
برنامه نوشته‌شده باید در بهینه‌ترین\LTRfootnote{Optimal}
شکل ممکن باشد تا بعدها برنامه‌نویس دیگری به بهانه‌ی بهینه‌سازی\LTRfootnote{Optimization}
برنامه‌ی سابق با ایجاد تغییرات نادرست سبب نامنظم‌شدن و کثیف‌شدن کد نشود.
    \end{itemize}

در عمل، در اکثر مواقع شما بعد از یک طراحی نسبتاً خوب و پیاده‌سازی آن، برای مدتی طولانی از آن کد برا هدف خود استفاده می‌کنید و در طول این مدت تعییرات و قابلیت‌های زیادی را به آن می‌افزایید.

پس از مدتی نه‌چندان طولانی، این تغییرات باعث می‌شوند که شما دیگر عملکرد کد را به‌وضوح متوجه نشوید و به تبع آن، توانایی تغییر و ارتقای کد را نیز از دست می‌دهید. همین زنجیره‌ی اتفاقات به ظاهر ساده در تاریخچه‌ی نسبتاً کوتاه توسعه‌ی نرم‌افزاری باعث نابود‌شدن شرکت‌های بسیاری در این عرصه شده است.

حال با توجه به خطرات و مشکلاتی که یک کد کثیف به همراه دارد، باید راه‌حلی برای رفع کثیف‌بودن کد و جلو‌‌گیری از ایجاد آن اراﺋﻪ دهیم. شما در این تمرین کامپیوتری با روند بازسازی\LTRfootnote{Refactoring} کد آشنا می‌شوید.

بازسازی عملیاتی است که در طی آن ساختار یک نرم افزار به صورتی تغییر و بهبود می‌یابد که بدون از دست‌رفتن کارآیی‌ها و تغییر رابط کاربری\LTRfootnote{Interface} برنامه، ساختار درونی کد به طرز قابل توجهی تمیزتر می‌شود.

بنیادی‌ترین مفهوم یاری‌کننده‌ی یک برنامه‌نویس در طی عملیات بازسازی شناخت عناصری است که باعث کثیف شدن کدها می‌شوند و به اصطلاح به آن‌ها Code Smells گفته می‌شود.

وظیفه‌ی شما در این تمرین بازسازی کد خودتان در تمرین اول درس است؛ بنابراین \textbf{خوانایی و تمیزبودن کد} در این تمرین بیشترین اهمیت را دارد. در ادامه توضیحاتی درباره‌ی بازسازی کد اراﺋﻪ می‌شود. پیشنهاد می‌کنیم که ابتدا تا پایان صورت تمرین را مطالعه کنید و سپس شروع به بازسازی کد خود کنید.
\newpage
\section{کد تمیز}
عواملی در کد وجود دارند که ممکن است باعث کثیف‌شدن آن شوند؛ در ادامه برخی از این عوامل توضیح داده شده‌اند. توجه کنید که در انتهای این تمرین نمره شما فقط بر اساس عوامل زیر سنجیده می‌شود و به ازای هر یک از موارد زیر که در کد شما وجو داشته باشد نمره‌ی شما کاسته خواهد شد. ساختار کلی کد و طراحی شما نباید تغییر کند و فقط ساختار درونی آن می‌تواند تغییر کند.\\
این عوامل خلاصه‌ای از کتاب Clean Code هستند و عبارت انتهای هر عامل فصل و شماره‌ای آن عامل را در کتاب نشان می‌دهد.

\subsection{نام‌گذاری (فصل ۲)}
  \begin{itemize}
        \item
نام کلاس‌ها و اشیا\LTRfootnote{Objects} باید عبارت‌های اسمی\LTRfootnote{Noun Phrase} مثل Customer و Account باشند و با حرف بزرگ\LTRfootnote{Capital} شروع شوند.
	\item
نام توابع باید عبارت‌های امری\LTRfootnote{Verb Phrase} مثل get , set و deletePage باشند و با حرف کوچک شروع شوند.
    \end{itemize}

\subsection{توابع (فصل ۳)}
  \begin{itemize}
	\item
		\lr{Functions should do one thing. They should do it well. They should do it only.}
        \item
توابع باید تا حد امکان \textbf{کوتاه} باشند.
تابع باید حداکثر ۶ (۸‌؟) خط باشد.
	\item
تابع باید حداکثر یک به یک سطح پایین‌تر دسترسی داشته باشد. مثلا با یک حلقه روی لیستی از اشیا و تغییر ویژگی‌\LTRfootnote{property}های هر کدام از اشیا دسترسی به ۲ سطح پایین‌تر از تابع است. و این عملیات باید در تابعی جداگانه پیاده‌سازی شود.
	\item
تعداد آرگومان‌های تابع تا حد امکان کم باشد(حداکثر ۳ تا). در صورت امکان از آزگومان‌هایی از نوع اشیا استفاده شود. مثلا به جای دو متغیر از نوع \lr{double} از یک شئ از نوع  \lr{point} استفاده کنیم.
    \end{itemize}

\subsection{فرمتینگ (فصل ۵)}
  \begin{itemize}
        \item
\textbf{دندانه‌گذاری}\LTRfootnote{Indentation}
در کد اهمیت بالایی دارد و حتما هر محدوده\LTRfootnote{Scope} باید یک دندانه داخل‌تر باشد. همچنین هر تابع باید حداکثر یک یا دو دندانه داخل رفته باشد.
	\item
در نام‌گذاری توابع و متغیر‌ها از یک روش واحد نام‌گذاری\LTRfootnote{Naming Convention} استفاده شده باشد. مثلا یا همه متغیر‌ها به صورت CamelCase نام‌گذاری شده باشند و یا همه به صورت Snake\_case باشند. در هر صورت دیگر قوانین نام‌گذاری باید رعایت شوند.
    \end{itemize}


\subsection{\lr{Smells and Heuristics} (فصل ۱۷)}

	\subsubsection{کامنت‌ها}
	  \begin{itemize}
	        \item در این تمرین کامنت‌گذاری به هیچ نحوی قابل قبول نیست.
	    \end{itemize}


	\subsubsection{توابع}
	  \begin{itemize}
	        \item
آرگومان‌هایی که به عنوان خروجی تابع استفاده می‌شوند. یک تابع فقط باید بتواند از طریق مقدار بازگشتی خود بر محیط بیرون تأثیر بگذارد و نتواند از طریق تغییر آرگومان‌ها بر محیط تأثیری داشته باشد. (\lr{F2})
		\item
آرگومان از نوع بولین\LTRfootnote{Boolean} برای تعیین نحوه عملکرد کد؛
مثلا پاس دادن یک متغیر به نام \lr{flag} به تابع، فقط برای اجرای یک بخش کد در حالتی خاص. چنین تابعی در واقع دو تابع مختلف است که باید به صورت جدا از هم پیاده‌سازی شوند و در زمان مناسب فراخوانی\LTRfootnote{Call} شوند. (\lr{F3})
	   \end{itemize}

	\subsubsection{نام‌گذاری}
	  \begin{itemize}
	        \item
استفاده از نام‌های نامرتبط. مثلا استفاده از متغیر‌هایی با نام‌های a و b که هیچ توضیحی ارائه نمی‌دهند و خواننده را گیچ می‌کنند. نام متغیر باید کاربرد و مکان استفاده از متغیر را نشان دهد. همچنین نام تابع باید وظیفه تابع و تأثیرات\LTRfootnote{Side-Effects} احتمالی تابع روی محیط را توضیح دهد. (\lr{N1})
	   \end{itemize}

	\subsubsection{مشکلات کلی}
	  \begin{itemize}
	        \item
\textbf{کد تکراری}\LTRfootnote{Duplication}.
از مهم‌ترین نکاتی که باید در این تمرین رعایت کنید، جلوگیری از کد تکراری است و کد تکراری به هیچ وجه قابل قبول نیست. (\lr{G5})
		\item
کدهای مرده؛ کدهایی که دیگر در هیچ قسمتی از برنامه فراخوانی نمی‌شوند نباید در متن برنامه وجود داشته باشند. (\lr{G9})
		\item
عدم ثبات و هماهنگی در کد؛ \textbf{ثبات}\LTRfootnote{Consistency} یکی دیگر از نکات مهم در کد نویسی است. سعی کنید که همیشه از یک الگو و روند در پیاده‌سازی و نام‌گذاری‌های خود استفاده کنید. (\lr{G11})
		\item
استفاده از اعداد جادویی\LTRfootnote{Magic Numbers}؛ اعداد و ثابت‌ها نباید به طور مستقیم در کد استفاده شوند و باید در متغیر‌های ثابت ذخیره شوند و از این متغیر‌ها در کد استفاده شود. مثلا عدد $\pi$ را در ابتدای برنامه در متغیری به نام PI ذخیره کنیم و از این ثابت در بقیه کد استفاده کنیم. (\lr{G25})
		\item
انجام بیش از یک کار در یک تابع؛ هر تابع باید فقط یک کار را انجام دهد و این کار را به شیوه درستی پیاده و اجرا کند. همچنین نباید در کنار انجام این کار تأثیری در متغیرها و دیگر اجزای برنامه داشته باشد. (\lr{G30})

	   \end{itemize}
\section*{نکات پایانی}
	  \begin{itemize}
	        \item
توجه کنید که هدف از این تمرین بازسازی کد خودتان است و نباید ساختار کلی و طراحی شما تغییر کند.
		\item
توجه کنید که کد نهایی شما توسط تست‌کیس‌های پروژه ۱ نیز آزموده خواهند شد و برای این قسمت نمره‌ای در نظر گرفته شده است.
		\item
یک نمونه از بازسازی کد را می‌توانید مشاهده کنید ...... ToDo

	  \end{itemize}

\section{نحوهٔ تحویل}
    پروندهٔ\LTRfootnote{file} برنامهٔ خود را با نام \lr{R-SID.cpp} در صفحهٔ \lr{CECM} درس بارگذاری کنید که \lr{SID} شمارهٔ دانشجویی شماست؛ برای مثال اگر شمارهٔ دانشجویی شما ۸۱۰۱۹۷۹۹۹ باشد، نام پروندهٔ شما باید \lr{R-810197999.cpp} باشد.
    \begin{itemize}
        \item
برنامهٔ شما باید در سیستم‌عامل لینوکس و با مترجم \lr{g++} با استاندارد \lr{\texttt{c++11}} ترجمه و در زمان معقول برای ورودی‌های آزمون اجرا شود.
        \item
در این تمرین اجازهٔ استفاده از مفاهیم شیءگرایی را \textbf{ندارید}.
        \item
از صحت قالب\LTRfootnote{format} ورودی‌ها و خروجی‌های برنامهٔ خود مطمئن شوید. توجه کنید که آزمون خودکار برنامه به \textbf{تعداد و محل فاصله‌ها و خطوط خالی} نیز حساس است. توصیه می‌کنیم حتماً برنامهٔ خود را با ورودی و خروجی نمونه بیازمایید و از ابزارهایی مانند \lr{\texttt{diff}} برای اطمینان از درستی عملکرد برنامهٔ خود برای ورودی نمونه استفاده کنید.
        \item
هدف این تمرین یادگیری شماست. لطفاً تمرین را خودتان انجام دهید. در صورت کشف تقلب مطابق قوانین درس با آن برخورد خواهد شد.
    \end{itemize}
\end{document}
