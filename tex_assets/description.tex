\documentclass{utap}

\usepackage{keyval}
\usepackage{calc}
\usepackage{multicol}
\usepackage{graphicx}
\usepackage{amsmath}
% \usepackage{wrapfig}
\usepackage{xepersian}

\graphicspath{ {./images/} }

\title{تمرین  امتیازی}
\author{
    \href{mailto:bardia.eghbali@gmail.com?subject=[AP\%20S98\%20Refactoring]\%20}{بردیا اقبالی},
    \href{mailto:ahhabibvand@gmail.com?subject=[AP\%20S98\%20Refactoring]\%20}{امیرحسین حبیب‌وند}
}
\course{برنامه‌سازی پیشرفته}
\deadline{جمعه ۱۶ فروردین ۱۳۹۸، ساعت ۲۳:۵۵}
\lecturer{رامتین خسروی}

\begin{document}

\lstset{
    numbers=left,
    frame=leftline,
}

\maketitle

\section{بازسازی}
تعاریف زیادی از
"ﮐﺪ ﺗﻤﯿﺰ"\LTRfootnote{Clean Code}
وجود دارد؛ اما احتمالا یکی از بهترین تعریف‌ها متعلق به
"ﺑﯿﺎرﻧﻪ اﺳﺘﺮاﺳﺘﺮوپ" \LTRfootnote{Bjarne Stroustrup}
خالق و توسعه‌دهنده‌ی زبان \lr{\texttt{C++}} است. وی در تعریف خود از یک کد تمیز، دو مورد زیر را به عنوان معیار‌های اساسی یک کد تمیز بر می‌شمارد:

    \begin{itemize}
        \item
منطق و الگوریتم کد باید آن‌قدر واضح و قابل‌فهم باشد که اشکالات و نقص‌های ﺟﺰﺋﯽ نتوانند از چشم برنامه‌نویس و آزمونگر کد دور بمانند؛ ضمن این که وضوح کد باید به حدی بالا باشد که برنامه‌نویس را از نوشتن کامنت\LTRfootnote{Comment} بی‌نیاز کند.

        \item
کارایی\LTRfootnote{Performance}
برنامه نوشته‌شده باید در بهینه‌ترین\LTRfootnote{Optimal}
شکل ممکن باشد تا بعدها برنامه‌نویس دیگری به بهانه‌ی بهینه‌سازی\LTRfootnote{Optimization}
برنامه‌ی سابق با ایجاد تغییرات نادرست سبب نامنظم‌شدن و کثیف‌شدن کد نشود.
    \end{itemize}

در عمل، در اکثر مواقع شما بعد از یک طراحی نسبتاً خوب و پیاده‌سازی آن، برای مدتی طولانی از آن کد برا هدف خود استفاده می‌کنید و در طول این مدت تعییرات و قابلیت‌های زیادی را به آن می‌افزایید.

پس از مدتی نه‌چندان طولانی، این تغییرات باعث می‌شوند که شما دیگر عملکرد کد را به‌وضوح متوجه نشوید و به تبع آن، توانایی تغییر و ارتقای کد را نیز از دست می‌دهید. همین زنجیره‌ی اتفاقات به ظاهر ساده در تاریخچه‌ی نسبتاً کوتاه توسعه‌ی نرم‌افزاری باعث نابود‌شدن شرکت‌های بسیاری در این عرصه شده است.

حال با توجه به خطرات و مشکلاتی که یک کد کثیف به همراه دارد، باید راه‌حلی برای رفع کثیف‌بودن کد و جلو‌‌گیری از ایجاد آن اراﺋﻪ دهیم. شما در این تمرین کامپیوتری با روند بازسازی\LTRfootnote{Refactoring} کد آشنا می‌شوید.

بازسازی عملیاتی است که در طی آن ساختار یک نرم افزار به صورتی تغییر و بهبود می‌یابد که بدون از دست‌رفتن کارآیی‌ها و تغییر رابط کاربری\LTRfootnote{Interface} برنامه، ساختار درونی کد به طرز قابل توجهی تمیزتر می‌شود.

بنیادی‌ترین مفهوم یاری‌کننده‌ی یک برنامه‌نویس در طی عملیات بازسازی شناخت عناصری است که باعث کثیف شدن کدها می‌شوند و به اصطلاح به آن‌ها Code Smells گفته می‌شود.

وظیفه‌ی شما در این تمرین بازسازی کد خودتان در تمرین اول درس است؛ بنابراین \textbf{خوانایی و تمیزبودن کد} در این تمرین بیشترین اهمیت را دارد. در ادامه توضیحاتی درباره‌ی بازسازی کد اراﺋﻪ می‌شود. پیشنهاد می‌کنیم که ابتدا تا پایان صورت تمرین را مطالعه کنید و سپس شروع به بازسازی کد خود کنید.
\newpage
\section{کد تمیز}
عواملی در کد وجود دارند که ممکن است باعث کثیف‌شدن آن شوند؛ در ادامه برخی از این عوامل توضیح داده شده‌اند. توجه کنید که در انتهای این تمرین نمره شما فقط بر اساس عوامل زیر سنجیده می‌شود و به ازای هر یک از موارد زیر که در کد شما وجو داشته باشد نمره‌ی شما کاسته خواهد شد. ساختار کلی کد و طراحی شما نباید تغییر کند و فقط ساختار درونی آن می‌تواند تغییر کند.\\
این عوامل خلاصه‌ای از کتاب Clean Code هستند و عبارت انتهای هر عامل فصل و شماره‌ای آن عامل را در کتاب نشان می‌دهد.

\subsection{نام‌گذاری (فصل ۲)}
  \begin{itemize}
        \item
نام کلاس‌ها و اشیا\LTRfootnote{Objects} باید عبارت‌های اسمی\LTRfootnote{Noun Phrase} مثل Customer و Account باشند و با حرف بزرگ\LTRfootnote{Capital} شروع شوند.
	\item
نام توابع باید عبارت‌های فعلی\LTRfootnote{Verb Phrase} مثل get , set و deletePage باشند و با حرف کوچک شروع شوند.
    \end{itemize}

\subsection{توابع (فصل ۳)}
  \begin{itemize}
	\item
		\lr{Functions should do one thing. They should do it well. They should do it only.}
        \item 
توابع باید تا حد امکان \textbf{کوتاه} باشند.
تابع باید حداکثر ۶ (۸‌؟) خط باشد.
	\item
تابع باید حداکثر یک به یک سطح پایین‌تر دسترسی داشته باشد. مثلا با یک حلقه روی لیستی از اشیا و تغییر ویژگی‌\LTRfootnote{property}های هر کدام از اشیا دسترسی به ۲ سطح پایین‌تر از تابع است. و این عملیات باید در تابعی جداگانه پیاده‌سازی شود.
	\item
تعداد آرگومان‌های تابع تا حد امکان کم باشد(حداکثر ۳ تا). در صورت امکان از آزگومان‌هایی از نوع اشیا استفاده شود. مثلا به جای دو متغیر از نوع \lr{double} از یک شئ از نوع  \lr{point} استفاده کنیم.
    \end{itemize}

\subsection{فرمتینگ (فصل ۵)}
  \begin{itemize}
        \item 
\textbf{دندانه‌گذاری}\LTRfootnote{Indentation}
در کد اهمیت بالایی دارد و حتما هر محدوده\LTRfootnote{Scope} باید یک دندانه داخل‌تر باشد. همچنین هر تابع باید حداکثر یک یا دو دندانه داخل رفته باشد.
	\item
در نام‌گذاری توابع و متغیر‌ها از یک روش واحد نام‌گذاری\LTRfootnote{Naming Convention} استفاده شده باشد. مثلا یا همه متغیر‌ها به صورت CamelCase نام‌گذاری شده باشند و یا همه به صورت Snake\_case باشند. در هر صورت دیگر قوانین نام‌گذاری باید رعایت شوند.
    \end{itemize}


\subsection{\lr{Smells and Heuristics} (فصل ۱۷)}

	\subsubsection{کامنت‌ها}
	  \begin{itemize}
	        \item در این تمرین کامنت‌گذاری به هیچ نحوی قابل قبول نیست.
	    \end{itemize}


	\subsubsection{توابع}
	  \begin{itemize}
	        \item آرگومان‌هایی که به عنوان خروجی تابع استفاده می‌شوند. یک تابع فقط باید بتواند از طریق مقدار بازگشتی خود بر محیط بیرون تأثیر بگذارد و نتواند از طریق تغییر آرگومان‌ها بر محیط تأثیری داشته باشد.
		\item آرگومان از نوع بولین\LTRfootnote{Boolean} برای تعیین نحوه عملکرد کد؛
مثلا پاس دادن یک متغیر به نام \lr{flag} به تابع، فقط برای اجرای یک بخش کد در حالتی خاص. چنین تابعی در واقع دو تابع مختلف است که باید به صورت جدا از هم پیاده‌سازی شوند و در زمان مناسب صدا\LTRfootnote{Call} شوند.
	    \end{itemize}

\end{document}
